# JVM
---

## jvm的内存结构
()[../images/java内存结构.png]

jvm 运行时数据区

* 程序计数器---线程私有
* Java虚拟机栈---线程私有
* 本地方法栈---线程私有
* Java堆---线程公用
* 方法区---线程公用

## JVM内存分配

### 栈内存分配 
`-xss`
* 保存参数, 局部参数, 中间计算过程和其他数据. 退出方法的时候, 修改栈顶指针的就可以把栈指针的内容销毁. 
* 栈的优点: 存取速度比堆快, 仅次于寄存器, 栈数据可以共享
* 栈的缺点: 存在栈中的数据大小, 生存期在编译时确定的, 导致缺乏灵活性.

### 堆内存分配

* 堆的优点: 动态的分配内存大小, 生存期不必事先告诉编译器, 它是在运行期动态分配的, 垃圾回收会自动收走不再使用的空间区域.

* 堆的缺点: 运行时动态分配内存, 在分配和销毁时都要占用时间, 因此堆的效率低.


JVM堆结构
(../images/jvm堆结构.png)[../images/]

Young区: eden, survior space(s1, s2)

OLD:
Permanent: 字节码, 静态类


### jjava堆结构和垃圾回收
GC:
Perm Gen:
Minor Gc: 只在young 代里进行gc
Full Gc: 全部进行gc


java堆结构和垃圾回收.png

### jvm 堆配置参数

* -xms 初始堆大小: 默认物理内存的1/64
* -xmx 最大堆大小: 默认物理呢村的1/4, 实际建议不大于4GB
* 一般建议设置 Xms=xmx: 好处是避免每次在gc后, 调整堆大小, 减少系统内存分配开销
* 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小

### jvm新生代 (young generation)
* 新生代= 1个eden区+2个Survivor区
* -Xmn 年轻代大小(1.4 or later) 默认大小为整个堆的3/8
* -XX:NewRatio  年轻代(包括Eden和两个Surivior) 与年老代的比值(除去持久代)
  * xms=Xmx 并且设置了Xmn情况下, 该参数不需要进行设置

* -XX:SurvivorRatio: Eden区域Surivior区的大小比值, 设置为8, 则两个Surivvor区的比值为2:8, 一个Survivor 区站整个年轻代的1/10
* 用来存放Jvm刚分配的Java对象.


### Java 年老代
* 老年代 = 整个堆 -年轻代 -持久代
* 年轻代中经过垃圾回收没有回收掉的对象被复制到年老代
* 老年代存储对象比年轻代年龄大的多, 而且不乏大对象
* 新建的对象也有可能直接进入老年代:
  - 大对象, 可用过启动参数设置-XX:PreteenureSizeThreshold=1024(单位为字节, 默认为0)来代表超过多大时就不在新生代分配, 而直接在老年代分配
  - 大的数组对象, 且数组中无引用外部对象
* 老年代大小无配置参数

### 持久代
* 持久代=整个堆 - 年轻代大小 - 老年代
* -XX:PermSize -XX:MaxPermSize: 设置持久代大小, 一般推荐设置为相同值,
* 存放Class, Method原信息, 其大小与项目的规模, 类, 方法的数量有关. 一般设置为128M就足够, 设置原则是预留30%.
* 永久代的回收方式
  - 常量池中的常量, 无用的 类信息, 常量的回收很简单, 没有引用就可以被回收
  - 对于无用的类进行回收, 保证三点:
    * 类的所有实例都已经被回收
    * 加载类的ClassLoder 已经被回收
    * 类的对象没有被引用(即没有通过反射引用该类的地方)


### jvm垃圾收集算法

* 引用计算算法: 
  - 每个对象有一各引用计数属性, 新增一个引用时计数加1, 引用释放时计数减1, 计数为0可以回收. 此方法简单, 无法解决对象相互循环引用的问题.  还有一个问题就是如何解决精准计数
* 根搜索算法
  - 从GC Roots 开始向下搜索, 搜索所走过的路径称为引用链. 当一个对象到Gc Roots都没有任何引用链相连时, 此证明对象时不可用的.

Java语言中, GC Roots包括:
* 虚拟机栈中引用的对象
* 方法去类静态属性实体引用的对象
* 方法区常量引用的对象
* 本地方法栈中JNI引用的对象.


### jvm垃圾回收算法
* 复制算法(copying)
* 标志清除算法(Mark-sweep)
* 标记整理压缩算法(mark-compac)

### 名词解释
* 串行回收: gc但线程内存回收, 会暂停所有用户线程
* 并行回收: 收集是指多个GC线程并行工作, 但此时用户线程时暂停的; 所以, Serial时串行的, Parallel收集器时并行的, 而CMS收集器时并发的.
* 并发回收: 指用户线程与gc线程同时执行(不一定时并行, 可能交替, 但总体上时同时执行的), 不需要停顿用户线程(其实在CMS中用户线程还是需要暂停的, 只是非常短暂, gc线程在另一个CPU执行).

### JVM常见垃圾回收器
`年轻代中的回收器`: Serial(串行), ParNew(并行), Parallel Scanvenge
`(年老代)Tenured generation`: cms(), Serial old(msc), Paralled old

* 串行回收: 全部暂停, 独占
* 并行回收: -XX:UseParNewGc  开启, 新生代使用并行回收, 年老代使用串行回收
  * -XX:ParakkekGcThreads 指定线程数. 没人最好与cpu数量相同, 避免过多的线程数影响垃圾收集性能
* 并发回收

### Serial 回收器(串行回收器)
1. 是一个单线程的收集器, 只能使用一个CPU或者一条线程去完成垃圾收集; 在进行垃圾收集时, 必须暂停所有的其他线程, 直到收集完成.
2. 缺点: Stop-The-World
3. 优势: 简单. 对于但CPU的情况, 由于没有多线程交互开销, 反而可以更高效. 是client模式下默认的新生代收集器.

#### 新生代Serial回收器
1. -XX:+UseSerialGc 开启
  * Serial New+ Serial old 的收集器组合进行内存回收
2. 使用复制算法
3. 独占式的垃圾回收: 一个线程进行GC, 串行. 其他工作线程停止.

#### 年老代Serial回收器
1. -XX:+UserSerialGC 开启
  * Serial New +Serial old的收集器组合进行内存回收
2. 使用标记-压缩算法
3. 串行, 独占的垃圾回收器: 因为内存比较大的原因, 回收比新生代慢.

### ParNew 回收器(并行回收器)
并行回收器也是独占式的回收器, 在收集过程中,应用程序会全部暂停. 但由于并行回收器使用多线程进行垃圾回收, 因此, 在并发能力比较强的CPU上, 它产生的停顿时间要短于串行回收器, 而在单CPU或者并发能力较弱的系统中, 并行回收器的效果不会比串行回收器好, 由于多线程的压力, 它的实际表现很可能比串行收集器差.


#### 新生代 ParNew 回收器
1. -XX:+UserParNewGC 开启
  * 新生代使用并行回收收集器, 老年代使用串行收集器
2. -XX:ParallelGCThreads 指定线程数: 默认最好与CPU数目相当, 避免过多的线程数影响垃圾收集性能.
3. 使用复制算法
4. 并行的, 独占式的垃圾回收器

### 新生代Parallel Scavenge 回收器
1. 吞吐量优先回收器:
  * 关注CPU吞吐量, 即运行用户代码的时间/总时间, 比如: JVM运行100分钟, 其中运行用户代码99分钟, 垃圾收集1分钟, 则吞吐量位99%, 这种收集器能最高效率的利用CPU, 适合运行后台运算.
2. -XX:+UserParallelGc 开启: 
  * 使用Parallel Scavengen + Serial Old收集器组合回收垃圾, 这也是Server模式下的默认值
3. -XX:GCTimeRatio:
  * 来设置用户执行时间占总时间的比例, 默认99, 即1%的时间用来进行垃圾收集
4. -XX:MaxGCPauseMillis: 设置GC的最大停顿的时间
5. 使用复制算法

### 年老代Parallel Old 回收器
1. -XX:+UseParallelOldGC 开启: 使用Parallel Scavenge + Parallel Old组合收集器进行收集
2. 使用标记整理算法
3. 并行的, 独占式的垃圾回收器
 

## CMS(并发标记清除)回收器
运作过程分为4个阶段:
* 初始标记(CMS initial mark): 值标记GC Roots能直接关联到对象
* 并发标记(CMS concurrent mark): 进行GC RootsTracing 的过程
* 重新标记(CMS remark): 修正并发标记期间因用户程序继续运行而导致标记发生改变的那一部分对象进行标记
* 并发清除(CMS concurrent sweep)

其中标记和重新标记两个阶段仍然需要Stop-The-World, 整个过程中耗时最长的标记和比广发清除过程中收集器都可以和用户线程一起工作.

### CMS(并发标记清除) 回收器
1. 标记-清除算法: 同时它又是一个使用多线程并回收的垃圾收集器
2. -XX:ParallelCMSThreads: 手工设定CMS的线程数量, 默认启动的线程数时(ParallelGCThreads+3/4), cpu核数 + 1
3. -XX:+UserConCMarkSweepGC 开启:
  * 使用 ParNew + CMS + SerialOld 的收集器组合进行内存回收, Serial Old作为CMS出现 "COncurrentMode Failure" 失败后的后备收集器
4. -XX:CMSInitiatingOccupancyFraction: 死而后止CMS收集器在年老代空间被使用多少后触发垃圾收集器, 默认值位68%, 尽在CMS收集器时有效, -XX:CMSInitatingOccupancyFraction=70
5. -XX:+UseCMSCompactAtFullCollection
  * 设置CMS收集器在进行若干此垃圾收集后再进行一次内存碎片整理过程, 通常与UseCMSCompactAtFullCollection 参数一起使用
6. -XX:CMSInitiatingPermOccupancyFraction
  * 设置Perm Gen 使用到达多少比率时触发, 默认92% 


### GC性能指标

* 吞吐量: 应用花在非GC的时间比
* GC负荷: 与吞吐量相反, 指应用花在GC的时间百分比
* 暂停时间: 应用花在GC stop-the-world 的时间
* GC频率: 顾名思义
* 反应速度: 从一个对象标称垃圾到这个对象被回收的时间
* 一个交互式应用要求暂停时间越少越好, 然而, 一个非交互性应用,当然希望GC负荷越低越好.
* 一个实时系统对暂停时间和GC负荷的要求, 都是越低越好
* 一个嵌入式系统当然希望Footprint 越小越好

### 内存容量配置原则

1. 年轻代大小选择:
 * 响应时间优先的应用: 尽可能设大, 直到接近系统的最低响应时间限制(根据实际情况选择). 在此种情况下, 年轻代收集的频率也是最小的, 同时,减少到达年老代的对象.
 * 吞吐量优先的应用: 尽可能的设置大, 可能达到Gbit的程度, 因为响应时间没有要求, 垃圾回收可以并行进行, 一般适合8CPU以上的应用
 * 避免设置过小. 当新生代设置过小时会导致:
   1. YGC次数更加频繁
   2. 可能导致Young GC对象直接进入年老代, 如果此时年老代满了, 会触发FullGC

2. 年老代大小选择:
  * 响应时间的应用: 年老代使用并发收集器, 所以其大小需要小心设置, 一般会考虑并发会话率和会话持续时间等一些参数. 如果堆设置小了, 可能会造成内存碎片, 高回收频率以及应用暂停而使用传统的标记清除方式; 如果堆大了, 则需要较长的收集时间. 最优的方案, 一般需要参考日下数据获得:
    1. 并发垃圾收集信息, 持久带并发收集次数, 传统GC信息, 花在年轻代和年老代回收的时间比例
  * 吞吐量优先的应用: 一般吞吐量优先的应用都是有一个 很大的年轻代和一个较小的年老代. 原因时, 这样可以尽可能回收掉大部分短期数据, 减少中期的对象, 而年老代近存放长期存活对象.
  
