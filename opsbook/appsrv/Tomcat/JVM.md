# JVM
---

## jvm的内存结构
()[../images/java内存结构.png]

jvm 运行时数据区

* 程序计数器---线程私有
* Java虚拟机栈---线程私有
* 本地方法栈---线程私有
* Java堆---线程公用
* 方法区---线程公用

## JVM内存分配

### 栈内存分配 
`-xss`
* 保存参数, 局部参数, 中间计算过程和其他数据. 退出方法的时候, 修改栈顶指针的就可以把栈指针的内容销毁. 
* 栈的优点: 存取速度比堆快, 仅次于寄存器, 栈数据可以共享
* 栈的缺点: 存在栈中的数据大小, 生存期在编译时确定的, 导致缺乏灵活性.

### 堆内存分配

* 堆的优点: 动态的分配内存大小, 生存期不必事先告诉编译器, 它是在运行期动态分配的, 垃圾回收会自动收走不再使用的空间区域.

* 堆的缺点: 运行时动态分配内存, 在分配和销毁时都要占用时间, 因此堆的效率低.


JVM堆结构
(../images/jvm堆结构.png)[../images/]

Young区: eden, survior space(s1, s2)

OLD:
Permanent: 字节码, 静态类


### jjava堆结构和垃圾回收
GC:
Perm Gen:
Minor Gc: 只在young 代里进行gc
Full Gc: 全部进行gc


java堆结构和垃圾回收.png

### jvm 堆配置参数

* -xms 初始堆大小: 默认物理内存的1/64
* -xmx 最大堆大小: 默认物理呢村的1/4, 实际建议不大于4GB
* 一般建议设置 Xms=xmx: 好处是避免每次在gc后, 调整堆大小, 减少系统内存分配开销
* 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小

### jvm新生代 (young generation)
* 新生代= 1个eden区+2个Survivor区
* -Xmn 年轻代大小(1.4 or later) 默认大小为整个堆的3/8
* -XX:NewRatio  年轻代(包括Eden和两个Surivior) 与年老代的比值(除去持久代)
  * xms=Xmx 并且设置了Xmn情况下, 该参数不需要进行设置

* -XX:SurvivorRatio: Eden区域Surivior区的大小比值, 设置为8, 则两个Surivvor区的比值为2:8, 一个Survivor 区站整个年轻代的1/10
* 用来存放Jvm刚分配的Java对象.


### Java 年老代
* 老年代 = 整个堆 -年轻代 -持久代
* 年轻代中经过垃圾回收没有回收掉的对象被复制到年老代
* 老年代存储对象比年轻代年龄大的多, 而且不乏大对象
* 新建的对象也有可能直接进入老年代:
  - 大对象, 可用过启动参数设置-XX:PreteenureSizeThreshold=1024(单位为字节, 默认为0)来代表超过多大时就不在新生代分配, 而直接在老年代分配
  - 大的数组对象, 且数组中无引用外部对象
* 老年代大小无配置参数

### 持久代
* 持久代=整个堆 - 年轻代大小 - 老年代
* -XX:PermSize -XX:MaxPermSize: 设置持久代大小, 一般推荐设置为相同值,
* 存放Class, Method原信息, 其大小与项目的规模, 类, 方法的数量有关. 一般设置为128M就足够, 设置原则是预留30%.
* 永久代的回收方式
  - 常量池中的常量, 无用的 类信息, 常量的回收很简单, 没有引用就可以被回收
  - 对于无用的类进行回收, 保证三点:
    * 类的所有实例都已经被回收
    * 加载类的ClassLoder 已经被回收
    * 类的对象没有被引用(即没有通过反射引用该类的地方)


### jvm垃圾收集算法

* 引用计算算法: 
  - 每个对象有一各引用计数属性, 新增一个引用时计数加1, 引用释放时计数减1, 计数为0可以回收. 此方法简单, 无法解决对象相互循环引用的问题.  还有一个问题就是如何解决精准计数
* 根搜索算法
  - 从GC Roots 开始向下搜索, 搜索所走过的路径称为引用链. 当一个对象到Gc Roots都没有任何引用链相连时, 此证明对象时不可用的.

Java语言中, GC Roots包括:
* 虚拟机栈中引用的对象
* 方法去类静态属性实体引用的对象
* 方法区常量引用的对象
* 本地方法栈中JNI引用的对象.


### jvm垃圾回收算法
* 复制算法(copying)
* 标志清除算法(Mark-sweep)
* 标记整理压缩算法(mark-compac)

### 名词解释
* 串行回收: gc但线程内存回收, 会暂停所有用户线程
* 并行回收: 收集是指多个GC线程并行工作, 但此时用户线程时暂停的; 所以, Serial时串行的, Parallel收集器时并行的, 而CMS收集器时并发的.
* 并发回收: 指用户线程与gc线程同时执行(不一定时并行, 可能交替, 但总体上时同时执行的), 不需要停顿用户线程(其实在CMS中用户线程还是需要暂停的, 只是非常短暂, gc线程在另一个CPU执行).

### JVM常见垃圾回收器
`年轻代中的回收器`: Serial(串行), ParNew(并行), Parallel Scanvenge
`(年老代)Tenured generation`: cms(), Serial old(msc), Paralled old

* 串行回收: 全部暂停, 独占
* 并行回收: -XX:UseParNewGc  开启, 新生代使用并行回收, 年老代使用串行回收
  * -XX:ParakkekGcThreads 指定线程数. 没人最好与cpu数量相同, 避免过多的线程数影响垃圾收集性能
* 并发回收

### Serial 回收器(串行回收器)
1. 是一个单线程的收集器, 只能使用一个CPU或者一条线程去完成垃圾收集; 在进行垃圾收集时, 必须暂停所有的其他线程, 直到收集完成.
2. 缺点: Stop-The-World
3. 优势: 简单. 对于但CPU的情况, 由于没有多线程交互开销, 反而可以更高效. 是client模式下默认的新生代收集器.

#### 新生代Serial回收器
1. -XX:+UseSerialGc 开启
  * Serial New+ Serial old 的收集器组合进行内存回收
2. 使用复制算法
3. 独占式的垃圾回收: 一个线程进行GC, 串行. 其他工作线程停止.

#### 年老代Serial回收器
1. -XX:+UserSerialGC 开启
  * Serial New +Serial old的收集器组合进行内存回收
2. 使用标记-压缩算法
3. 串行, 独占的垃圾回收器: 因为内存比较大的原因, 回收比新生代慢.

### 新生代Parallel Sca 回收器
* 吞吐量优先回收器
* -XX:+UserParallelGc 开启: 
 

## CMS(并发标记清除)回收器
