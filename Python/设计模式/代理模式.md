# 代理模式
---
在某些应用中，我们想要在访问某个对象之前执行一个或多个重要的操作，例如，访问敏感
信息——在允许用户访问敏感信息之前，我们希望确保用户具备足够的权限。操作系统中也存在
类似的情况，用户必须具有管理员权限才能在系统中安装新程序。
我们想要把一个计算成本较高的对象的创建过程延迟到用户首次真正使用它时
才进行.

代理模式的类型:
* 远程代理:  实际存在于不同地址空间(例如, 某个网络服务器)的对象在本地的代理者.
* 虚拟代理: 用于延迟初始化, 将一个大计算量对象的创建延迟到真正需要的时候进行.
* 保护/防护代理: 控制对敏感对象的访问.
* 智能(引用)代理: 在对象被访问时执行额外的动作. 此类代理的例子包括引用计数和线程安全检查.


惰性计算
```py
class lazy_property(object):
    '''
    meant to be used for lazy evaluation of an object attribute.
    property should represent non-mutable data, as it replaces itself.
    '''

    def __init__(self, fget):
        self.fget = fget
        self.func_name = fget.__name__

    def __get__(self, obj, cls):
        if obj is None:
            return None
        value = self.fget(obj)
        setattr(obj, self.func_name, value)
        return value


class Test(object):

    @lazy_property
    def results(self):
        calcs = 1  # Do a lot of calculation here
        return calcs
```
t.cn/RqrYudC
我为自己写了一个...用于真正的一次性计算的惰性属性。我喜欢它，因为它避免了对对象附加额外的属性，一旦激活不浪费时间检查属性存在等。


### 现实生活的例子
银行卡, 代理了一个银行账号.

### 软件的例子

weakref 模块包含一个proxy() 方法, 该方法接受一个输入对象并将一个智能代理返回给该对象. 弱引用是为对象添加引用计数支持的一种推荐方式.
ZerMQ, Flask

### 应用案例
因为存在至少四种常见的代理类型, 所以代理设置模式有很多应用案例,如下所示:

1. 在使用私有网络或云搭建一个分布式系统时. 在分布式系统中, 一些对象存在于本地内存中,  一些对象存在于远程计算机的内存中. 如果我们不想本地代码关心两者之间的区别, 那么可以创建一个远程代理来隐藏/封装, 使得应用的分布式性质透明化.
2. 因过早创建计算成本较高的对象导致应用遭受性能问题之时. 使用虚拟代理引入惰性初始化, 尽在需要对象之时才创建, 能够明显提高性能.
3. 用于检查一个用户是否有足够权限来访问信息片段. 如果应用要处理敏感信息(例如, 医疗数据), 我们会希望确保用户在被准许之后才能访问/修改数据. 一个保护/防护代理可以处理所有安全相关的行为.
4. 应用(或库, 工具集, 框架等)使用多线程, 而我们希望把线程安全的重任从客户端代码转移到应用和. 这种情况下, 可以创建一个智能代理, 对客户端隐藏线程安全的复杂性.
5. 对象关系映射(ORM) API 也是一个如何使用远程代理的例子.
