# C程序设计语言
---
## 第1章导论

使用双引号括起来的字符序列成为字符串或者字符常量

### 1.4 符号常量
`#define 名字 替换文本`
"#define" 指令可以把符号名(或称为符号常量) 定义为一个特定的字符串
* 都是以字母开始的字母和数字数列
* 替换文本可以是任何字符序列, 而不仅限于数字
```c
# include <stdio.h>
#define LOWER 0
```


### 1.5 字符输入和输出
标准库提供的输入/输出模型非常简单, 无论文本从何处输入, 输出到何处, 其输入/输出都是按照字符流的方式处理. 文本流是输出多行字符构成的字符序列, 而每行字符则由0个货多个字符组成, 行末是一个换行符.

`getchar`: 从文本流中读入下一个输入字符, 并将其作为结果值返回.
`putchar`: 打印一个字符

```
c = getchar() // 从文本流读入下一个字符, 并将结果值返回, 通常是键盘输入.

putchar(c) // 打印一个字符

# 文件复制
```
### 1.6 数组

### 1.7 函数
函数的参数通过传值进行传递的.

```
返回值类型 函数名(0个或者多个参数声明){
    声明部分
    语句序列
    # return 表达式
}

int power(int base, int n){
    re
}
```

### 1.8 参数--传值调用
在C语言中, 被调用函数不能直接修改主调用函数中的值, 只能求改期私有的临时副本的值.

传值调用的利大于弊.
必要时, 也可以让函数能够修改主调函数中的变量. 这种情况下, 调用者需要向被调用函数提供待设置值的变量地址(地址就是指向变量的指针), 而被调用函数则需要将对应的参数声明为指针类型, 并通过它间接访问变量.

如果是数组参数, 情况就有所不同了. 当把数组名作为参数时, 传递给函数的值是数组的其实元素的位置或者地址----它并不复制数组元素本身. 在被调用函数中, 可以通过数组下标访问或者修改数组元素的值

### 1.9 字符数组
字符数组是C语言中最常用的数组类型.
从程序读入一组文本行的基本用法
```
while(还未处理的行)
if(该行比已处理的最长行还要长)
    保存该行
    保存该行的长度
打印最长的行
```

getline 的设计: 应该在读到文件末尾时返回一个信号; 更为有用的设计是它能够再度入文本行时返回该行的长度, 而遇到文件结束符时返回0. 由于不是有效的行长度, 因此可以作为标志文件结束的返回值. 每一行至少包括一个字符, 只包含换行符的行, 长度为1.
当发现某个新读入的行比以前读入的最长行还要长时, 需要把该行保存起来. 也就是说, 我们需要用另一个函数copy把最新行复制到一个安全的位置.
最后, 我们需要在主函数 main 中控制 getline 和 copy 这个两个函数.
```c
# include <stdio.h>
  # define MAXLINE 1000
  
  int getline(char line[], int maxline);
  void copy(char to[], char from[]);
  
main(){
      int len;
      int max;
      char line[MAXLINE];
      char longest[MAXLINE];
  
      max = 0;
      while ((len - getline(line, MAXLINE)) > 0){ 
          if (len>max){
              max = len;
              copy(longest, line);
          }   
      }   
      if(max > 0){ 
          printf("%s", longest);
      }   
      return 0;
  
  }
  
    int getline(char s[], int lim){
      int c, i;
      for (i=0; i<lim-1 && (c=getchar())!= EOF && c!='\n'; ++i){
          s[i] = c;
      }
      if(c=='\n'){
          s[i] = c;
          ++i;
      }
      s[i] = '\0';
      return i;
  }
  
  void copy(char to[], char from[]){
      int i;
      i = 0;
     while((to[i] = from[i])!= '\0') 
             ++i;
  }

```


### 1.10 外部变量和作用域
外部变量不息定义在所有函数之外, 且只能定义一次, 定义后编译程序将为它分配存储单元. 在每个访问外部变量的函数中, 必须声明相应的外部变量, 此时说明其类型. 声明时可以用extern语句显式声明, 也可以通过上下文隐式声明.


## 第二章 类型, 运算符与表达式

所有整型都包括signed(带符号)和unsigned(无符号)两种, 且可以表示无符号常量与十六进制常量. 浮点运算可以以单精度运行, 还可以使用更高精度的long double类型运算. 字符串常量可以在编译时连接. 支持枚举.

### 2.1 变量名
字母, 数字, 第一个必须时字母,'_'被看作为字母

### 2.2 数据类型及长度

C语言只提供了一下几种基本数据类型
* char 字符型, 只占用一个字节, 可以存放本地字符集中的一个字符
* int 整型, 通常反映了所用机器的整数的最自然的长度. 
* float 单精度浮点型
* double 双精度 浮点型

此外, 还可以在这些基本数据类型上加上一些限定符. short 与 long用于限定整型:
int 关键字可以省略

* short int:  通常为 16位
* long int: 通常位32位
* int 类型可以时16位或32位. 各编译器可以根据硬件特征自主选择合适的类型长度. 但要遵循下列限制: short与int 至少时16位, 而long至少是32位, 并且short 类型不得长于int类型, 而int类型不得长于long类型.

`类型限定符`: signend 与unsigend 限定char, 任何整型.
* unsigned 总是正直 或者0, 并遵守2^n定律, 其中n是该类型的占用的位数: 如char, unsigned char 位0-2^8
* signed, 是有负数的, 如char -128 -127(在采取对二的补码的机器上). 

> 不带限定符的char类型对象是否符号取决于具体机器, 但是打印字符总是正直.

long double 类型的表示的高精度的浮点数. 同整型一样, 浮点型的长度也取决于具体的实现, float, double 与long double 类型可以表示相同的长度, 也可以表示两种或者三种不同点长度.

有关这些长度的定义的符号常量以及其他的机器和编译有关的属性可以在标准头文件<limits.h>与<float.h>中找到

### 2.3 常量

1. 类似于1234的整数常量输入int 类型, long类型,常量以字母l或L结尾如1234L.
2. 如果整数太大至于无法用int类型表示时, 也将被当作long类型处理.
3. 无符号的常量以字u或U表示.
4. 后缀ul/UL表示 unsigned long 类型
5. 浮点数常量包含一个小数点或者一个指数 1e-2
6. 没有后缀的浮点数常量为double类型, 使用f/F表示float, l/L表示long double

整数:
1. 十进制
2. 八进制: 0开始的: 020
3. 十六进制: 0x/0X 开始

一个字符常量时一个整数, 书写时使用当引号'x'. 字符在机器字符几种的数值就是字符常量的值.

某些字符通过转义字符序列如`\n`表示位字符和字符串常量. 转义字符序列看起来像两个字符, 但只表示一个字符.
`\ooo` 表示任意的字节的位模式. 其中ooo代表1-3各八进制数字(0-7)
`\xhh`, 表示, 其中,hh是一个或多个十六进制的数字

```
//八进制表示
# define VTAB '\013' // ascii纵向制表符
# define BELL '\007' // ascii响铃符
//十六进制表示
# define VTAB '\xb'
# define BELL '\x7'
```

字符常量 '\0' 表示0个字符, 也就是空字符inull

> 常量表达式是仅仅包含常量的表达式, 这种表达式在编译时求值, 而不在运行时求值.

字符串常量也叫字符串字面值, 是用双引号扩起来的0个或多个字符组成的字符序列.
"hello, " "world" == "hello, world"

字符串常量就是字符数组, 字符串内部表示 使用空字符'\0'作为字符串结尾.
```
int strlen(char s[]){
    int i;
    i=0;
    while(s[i] != '\0'){
      ++i;
    }
    return i;
}
```

`枚举常量`: 是一个常量整型值的列表
enum boolean {NO, YES}; 没有显示说明情况下, enum类型的第一个枚举名的值为0, 第二个位1, 以此类推.
```c
enum escapes {
  BELL = '\a',
  BACSPACE = '\b',
  TAB = '\t',
};

enum moths {
  JAN = 1,
  FEB, MAR,APR...
  /* FEB为2, mar 3 依此类推 */
}
```

枚举为建立常量与名字之间的关联提共乐便利的方式, 相对于#define 语句,优势在于常量值可以自动生成. 编译器不检查这种类型的常量.


### 声明
所有变量都是先声明后市用. 尽管某些变量可以通过上下文隐式声明.
int lower, uper, step.

`任何变量的声明都可以使用const限定符限定`: 该限定符指定的变量赋值后不能修改.
```
const double e = 2.7121212;
const char msg[] = 'warning';
```
const 限定符也可以配合数组参数使用,它表明函数不能修改数组元素的值:
`int strlen()const char[])`

### 算数运算符
二元元素符: + - * / %
在负数操作数的情况下, 整数除法截取的方向以及取模运算取决于具体机器实现.
% 不能用于 float 和double


### 关系运算符与逻辑运算符
`> >= < <=`
== !=
关系运算符优先级比算数运算符低

逻辑运算符:
&& || , && 优先级比||高　都比　关系运算符低


### 类型转换

一般来说, 自动转换是指把 "比较窄的"操作数转换为"比较宽的"操作数, 并且不丢失信息的转换.

将字符类型转换为整型时, C语言没有指定char类型的变量是无符号的变量还是带符号的变量.
当把一个char类型的值转换为int 类型的值时, 其结果有没有可能为负数? 对于不同的机器, 其结果页不同, 这反应了不同机器结构之间的区别. 在这些机器中,如果char类型的值的最左一位为1, 则转换为负整数("进行符号扩展"). 而在另一些机器中, 把char类型值转换为int 时, 在插入类型值的左边添加0, 这样导致的转换结果值总是正值.

C语言的定义保证了机器的标准打印字符集中的字符不会是负值., 因此, 在表达式字符总是正值. 但是, 存储在字符变量中的位模式在某些机器中可能是负的, 而在另一些机器上可能是正值. 为了保证程序的可移植性, 如果要在char类型的变量中存储非字符数据, 最好指定signed 或 unsigned 限定符.

二元操作符(+,*) 做类型转换时, 如果没有unsigned类型操作符,符合下面的非正式的规则就可以:
1. 如果其中一个操作数的类型为long double, 则将另一个操作数转换为long double类型.
2. 如果其中一个操作数的类型为double, 则将另一个操作数转为double 类型
3. 如果其中一个操作数的类型是float, 则将另一个操作数转换为float类型
4. 将char与short类型操作数转换为int 类型
5. 如果其中一个操作数的类型为long, 则将另一个操作数也转换为long类型

> 表达式中float类型操作数不会自动转换为 double 类型. 一般来说, 数学好函数(如标准文件<math.h>中定义的函数)使用双精度类型变量. 使用float类型主要是为了在使用较大的数组时节省时间, 有时也为了节省机器执行时间(双精度算术运算特别费时).

当表达式中包含unsigned类型操作数时, 则转换规则要复杂一些. 主要原因在于, 带符号与无符号值之间的比较运算是与机器有关, 因为他们取决于机器中不同证书类型的大小. 如, 假定int类型占16位, long则占32位, 那么 -1L<1U, 这是因为unsigned int 类型1U被提升为signed long 类型, 但是-1L> 1U, 这是因为-1L兼备提升为unsigned long 类型, 因而成为一个比较大的正数.

当把较长的正数转换为较短的正数或char类型时, 超出的高位部分将被丢弃.
如果x是float类型, i是int 类型, 那么语句x=i与i=x在执行时进行类型转换. 当把float 类型转换为int 是, 小数部分会被劫取掉; 当把double类型转换为float 类型时, 是进行四舍五入还是截取取决于具体的实现.

在任何表达式中可以使用一个称为强制类型转换的一元运算符强制进行显示类型转换 `(类型名) 表达式`

### 2.8 自增运算与自减运算
++ 与 -- 这两个运算特殊的地方主要表现在: 他们既可以用作前缀运算符(用在变量前面如++n), 可以用作后缀运算符(n++). 在这两种情况下, 其效果是将变量n的值加1. 但是, 他们不同点:
表达式++n先将n的值加1, 然后再使用变量的n, 而表达式n++则是先使用变量n 在加加.
如果n=5
x=n++ 执行后x=5
x=++n 执行后x=6



### 2.9 按位运算符
C语言有6个位操作符. 这些运算符只能作用于整型操作符, 即只能作用于带符号或无符号的char, short, int 与 龙类型

& 按位与 (AND): 经常用于屏蔽某些二进制位
| 按位或 (OR): 常用于将某些二进制位置为1
^ 按位异或(XOR): 相同为0, 不同为1
<< 左移
\>> 右移: 有操作数必须是非负数
~ 按位求反(一元操作符)

异或:
参与运算的两个值，如果两个相应位相同，则结果为0，否则为1。即：0^0=0， 1^0=1， 0^1=1， 1^1=0
https://www.zhihu.com/question/31116687

### 2.10 赋值运算符与表达式


### 2.11 条件表达式

expr1 ? expr2: expr3
z = (a>b) ? a : b;
### 运算符优先级与求值次序


## 控制流


### 3.1 语句与程序块
在C语言中,用一堆花括号把一组声明和语句括在一起构成了一个复合语句 也叫作程序语句, 符合语句等价于单条语句. 

### 3.2 if -else 语句

if (表达式)
  语句1
else
  语句2

### 3.3 else-if

if(表达式)
   语句
else if (表达式)
  语句
else if (表达式)
  语句
else
  语句


### 3.4 switch语句
switch 语句是一种多路判定语句, 它测试吊打式是否与一些常量数值中的某一个匹配, 并执行相应的分支动作.

switch (表达式){
  case 常量表达式: 语句序列
  case 常量表达式: 语句序列
  default: 语句序列
}

每一个分支都一个或者多个整数值常量或者常量表达式标记. 如果某个分支与表达式的值匹配, 则从该分支开始执行. 各分支表达式必须互不相同. 如果没有哪一分支匹配,则执行默认的default分支. default 是可选的
```c
# include <stdio.h>
main()
{
    int c, i, nwhite, nother, ndigit[10];

    nwhite = nother = 0;
    for(i=0; i < 10; i++)
        ndigit[i] = 0;

    while((c=getchar())!=EOF){
      switch(c){
        case '0': case '1':  case '2': case '3': case '4':
        case '5': case '6':  case '7': case '8': case '9':
            ndigit[c-'0']++;
            break;
        case ' ':
        case '\n':
        case '\t':
            nwhite++;
            break;
        default:
            nother++;
            break;
        }
    }

}

```

break 语句将导致程序的执行即从switch 语句中退出. 在switch 语句中,case的作用只是一个标号, 因此某个分支中代码执行完成后, 程序将进入下一个分支继续执行, 除非在程序中显示的跳转. 跳出switch语句最常用的方法是使用break 语句与 return语句.

### 3.5 while 循环与for循环
while (表达式)
    语句
首先表达式的值, 如果其值为真非0, 则执行语句, 并再次求该值表达式的值. 这一循环过程一直进行下去.
for(表达式1; 表达式2; 表达式3)
  语句
从语法角度上看, for 循环语句的3个组成 部分都是表达式. 最常见的情况是, 表达式1余表达式3是赋值表达式或函数调用, 表达式2是关系表达式. 这三个表达式都可以省略但是分号必须保留.

### 3.6 do-while 循环
do
    语句
while(表达式);
先执行循环体的语句部分, 然后再求表达式的值. 如果表达式的值为真则再次执行语句, 知道为假时, 则循环停止. 最少执行一次.

### 3.7 break语句 与 continue 语句

### goto 语句与标号
C语言提供了可随意滥用的goto语句以及标记跳转位置的标号. 从理论上讲, 沟通语句是没有必要的, 实践中不使用goto语句也可以很容易写出代码.

break 只能跳出一层循环. 多层循环的跳出使用 goto  语句.
```c
for(...)
    for(...)
      ...
      if(disasert)
        goto error;


error:
  ddd
```


## 第四章 函数与程序结构


### 4.1 函数的基本知识

返回值类型 函数名(参数生命表){
  声明和语句;
}

函数之间的通信  可以通过参数, 函数返回值以及外部变量进行. 函数在源文件中出现的次序可以是任意的. 只要保证每一个函数不被分离到多个文件中, 源程序就可以分成多个文件.

被调用函数通过return 语句向调用者返回值, return 语句的后面可以跟任何表达式:
return 表达式;
在必要时,表达式将被转换为函数返回值类型. 表达式两边通常加一对圆括号. 此处可选.

### 4.2 函数非整型值的函数


> 如果函数带有参数, 则要声明它们; 如果没有参数, 则需要使用void进行声明.

### 4.3 外部变量
C语言程序可以看成由一系列的外部对象构成, 这些外部对心思昂可能是变量或函数. 形容词 external 与 internal 是相对的. internal 用于描述定义在函数内部的函数参数以及变量. 外部变量度定义在函数之外, 因此可以在许多函数中使用.  由于C语言不允许在一个函数中定义其他的函数, 因此函数本身是"外部的". 默认情况下, 外部变量与函数具有下列性质:
通过同一个名字对外部变量的所有引用(即使这种应用来自于单独编译的不同函数)实际上都是引用同一个对象(标准中把这一性质称为外部链接). 

在一个源程序的所有源文件中, 一个外部变量只能在某个文件中定义一次, 而其他的文件可以通过extern 来声明访问它(定义外部变量的源文件中也可以包含对该外部便利店extern声明). 外部变量的定义中必须制定数组的 长度, 但是  extern 声明则不一定要指定数组的长度.


如果函数之间需要共享大连的变量, 使用外部变量要比使用一个很长的参数表更方便有效.

### 4.4 作用域规则
构成C语言程序的函数与外部变量可以分开进行编译.  一个程序可以存放在几个文件中, 原先已经编译过的函数可以从库中进行加载.

名字的作用域指的是程序中可以使用改名字的部分. 对于在函数开头声明的自动变量来说, 起作用于是声明该变量名的函数. 不同函数中声明的具有相同名字的各个局部变量之间没有任何关系. 函数的参数也是这样的, 实际上可以将他看做是局部变量.

外部变量或者函数的作用域从声明它的地方开始, 到其所在的(待编译的)文件结束. 

如果要在外部变量的定义之前使用该变量, 或者外部变量的定义与变量的使用不在同一个源文件中,则必须在相应的变量生命中强制性的使用关在extern.

### 4.5 头文件

### 静态变量
用static声明限定外部变量与函数, 可以将其后声明的对象的作用域限定为被编译源文件的剩余部分. 通过static 限定外部对象, 可以达到隐藏外部对象的目的.

外部的static声明通常多用于变量, 当然, 也可以用于声明函数. 通常情况下, 函数名字是全局可访问的, 对整个程序的各个部分而言都可见. 但是, 如果把函数声明为static类型, 则该函数名除了对该函数声明所在的文件可见外, 其他文件都无法访问.

static也可用与声明内部变量. static类型的内部变量同自动变量一样, 是某个特定函数的局部变量, 只能在该函数中使用, 但它与自动变量不同的是, 不管其所在的函数时候被调用, 它一直存在, 而不像自动变量那样, 随着所在函数被调用和退出而存在和消失. 换句话说, static类型的内部变量是一种只能在某个特定函数中使用但一直占据存储孔家的变量.

### 4.7 寄存器变量
register 声明告诉编译器, 它所声明的变量在程序中使用频率较高. 其思想是, 将regiseter 变量放在机器的寄存器中, 这样可以是程序更小, 执行素对更快. 但编译器可以忽略此选项.
```
register int x;
register char ;
```

register声明只适用于自动变量以及函数的形式参数
```
f(register unsigned m, register long n){
   register int i;
}
```


### 4.8 程序块结构

以这种方式声明的变量可以隐藏程序块外与之同名的变量, 它们之间没有任何关系, 并在与左花括号匹配的右花括号之前一直存在,如
```
if(n>0){
  int i;
  for(i = 0; i < n; i++)
}
```
变量i的作用域是if语句的"真"分支, 这个i与该程序块外声明的i无关. 每次进入程序块是, 在程序块内声明以及初始化的自动比那里都将被初始化. 静态变量只在第一次进入程序块是被初始化一次.

### 4.9 初始化

### 4.10 递归

### 4.11 C预处理器
从概念上讲, 预处理器是编译过程中单独执行的第一个步骤. 两个最常用的预处理器的指令是: "# include 指令"(用于在编译期间把指定的文件的内容包含进当前文件中) 和 "#define" 指令(用任一字符序列替代一个标记)

`# include "文件名" `
或
`# include <文件名>`

### 宏替换
`# define  名字 替换文本`
这是一种最简单的宏替换---后续所有出现名字 记号的地方都将被替换为替换文本.

`#define` 指令中的名字和变量名的命名方式相同, 替换文本可以是任意字符串. 通常情况下, `#define 指令`在占一行, 替换文本是 `#define`指令行尾不的所有剩余部分内容, 但也是可以把一个较长的宏定义分成若干行, 这是需要在待续的行末尾加上一个反斜杠符号`\`. `#define` 指令定义的名字的作用域从其定一点开始, 到编译的源文件的末尾处结束. 宏定义中也可以使用前面的出现的宏定义. 替换只对记号进行, 对括号在引号的字符串不起作用.

```
# 替换文本可是任意的
#define forever for(;;);
#define max(A, B) ((A)>(B)?(A):(B))
```

#### 条件包含

`#if` 语句对其中的常量整型表达式(其中不能包含sizeof, 类型转换运算符或enum常量)进行求值, 若该表达式的值不等于0, 则包含其后的各行, 直到遇到`#endif`, `#elif`或者`#else` 语句为止(预处理器语句`#elif` 类似于`else if`). 在 `#if` 语句中可以使用表达式`defined(名字)`, 该表达式
的值遵循下列规则: 当名字已经定义是, 其值为1; 否则,其值为0;
```c
# if | defined(HDR)
# define HDR
#endif
# -------


# if SYSTEM == SYSV
    #define HDR "sysv.h"
# elif SYSTEM == BSD
    #define HDR "bsd.h"
# elif SYSTEM == MSDOS
    #define HDR "msdos.h"
# else
    #define HDR "default.h"
# endif

# include HDR
```



## 数据类型
char: 字符型, 一个字节
int: 整型, 32位,2字节  64位, 四个字节. 通常反应了所用机器中的整数最自然长度
short int: 1个字节
long  int: 4个字节

short与long两个限定符的引入可以为我们提供满足实际需要的不同长度的整型数.
int通常代表特定机器中证书自然长度. short通常是16位, long为32位, int类型可以是16或32位. 各自编译器可以根据硬件特性自主选择合适的类型长度, 但要遵循下列限制:
1. short 与int类型至少为16位, 而long类型至少为32位, 并且short类型不得长于int类型, 而int类型不得长于long类型.
2. 限定符signed与unsigned可用于限定char类型或任何类型. unsigned类型的数总是正值或0, 并遵守算术模2**n定律, 其中n是该类型占用的位数.
```
long a = 1L;
long b = 2UL; //代表unsigned long

```
float: 单精度浮点型, 4字节
double 双精度浮点型, 8字节
枚举: `enum boolean {NO, YES};` 在没有显式说明的情况下, 枚举类型中第一个枚举名的值为0, 第二个为1, 以此类推.
```
enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t', 
    NEWLINE = '\n', VTAB = '\v', RETURN = '\r'
};

enum months {JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC ;
};
//FEB 值为2, MAR的值为3, 以此类推
```


### 常量
常量表达式是仅仅包含常量的表达式. 这种表达式在编译时求值, 而不在运行时求值, 他可以出现在常量可以出现在任何位置.
```
#define MAXLINE 1000;
char line[MAXLINE + 1] // 或

```
`#define VTAB '\013'`; 
编译时可以将多个字符串常量连接起来, 如下列形式:
```
"hello," " world" // 等价于
"hello, world"
```

### 变量名
字母数字组成,但第一个字符必须是字母, 下划线"_"被看做是字母.

const, 限定词, 只能初始化一次, 以后不能更改. 限定数组, 限定数组中元素全不能修改.

### 类型转换


### 按位运算
提供了6个运算符, 这些只能用于整型操作符, char, short, int与long
`&`: 按位与
`|`: 按位或
`^`: 按位异或
`<<`: 左移
`>>`: 右移
`~`: 按位求反(一元运算符)

## 控制
```
if(){

}
else if()
{

}
case
{

}
```


### switch(表达式)
```
switch(表达式){
    case  常量表达式: 语句序列
    case  常量表达式: 语句序列
    default: 语句
}
#break
```


### while 与 for


### 函数
```
返回值类型 函数名(参数生命表){
    声明和语句
}
```























